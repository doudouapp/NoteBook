{
  "title": "GCD - 任务和队列",
  "cells": [
    {
      "type": "text",
      "data": "GCD是苹果为应对多核的并行运算提出的解决方案，它会自动利用多核进行并发处理和运算，它能提供系统级别的处理，而不再局限于某个进程、线程，官方声称会更快、更高效、更灵敏，且线程由系统自动管理，使用方便。"
    },
    {
      "type": "text",
      "data": "<h3>任务和队列</h3>"
    },
    {
      "type": "text",
      "data": "GCD 的两个核心：任务和队列。<div>任务：要执行的操作或方法函数。</div><div>队列：存放任务的集合，而我们要做的就是将任务添加到队列然后执行，GCD会自动将队列中的任务按<font color=\"#323232\" style=\"background-color: rgb(254, 250, 0);\">先进先出</font>的方式取出并交给对应线程执行。</div>"
    },
    {
      "type": "text",
      "data": "1. &nbsp;任务<div>加入任务时有两种形式：同步任务和异步任务。</div><div>同步任务：不会开启新的线程。会阻塞当前线程。</div><div>异步任务：会开启新的线程。不会阻塞当前线程。</div>"
    },
    {
      "type": "text",
      "data": "2. 队列<div>队列有两种队列，串行队列和并行队列。</div><div>串行队列：是指队列中的任务是一个接一个的执行，队首的任务执行完毕后才能执行其后面的任务，直至执行队尾的任务。尽可能使用一个线程。</div><div>并行队列：是指队列中的任务可以并发的执行，即开始执行队首的任务后，不必等其执行完毕就可以接着开始执行队首之后的任务，因此在某一个时刻可能存在同时执行的多个任务。</div>"
    },
    {
      "type": "text",
      "data": "队列和任务的四种组合方式：(swift)"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "// attributes 参数被指定为 concurrent 时，该队列为并发队列，不设置时，默认串行队列\n\nlet concurrentQueue = DispatchQueue(label: \"com.concurrent.queue\", qos: .utility, attributes: .concurrent)\n\nlet serailQueue = DispatchQueue(label: \"com.serail.queue\")"
    },
    {
      "type": "text",
      "data": "1.串行同步"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "func serialWithSync() {\n    serailQueue.sync {\n       print(Thread.current)\n        for  i in 0 ..< 3 {\n            print(\"aa = \",i)\n        }\n    }\n    \n    serailQueue.sync {\n        print(Thread.current)\n        for  i in 0 ..< 3 {\n            print(\"bb = \",i) \n        }\n    }\n    \n    serailQueue.sync {\n        print(Thread.current)\n        for  i in 0 ..< 3 {\n            print(\"cc = \",i)\n        }\n    }\n    print(\"end1\")\n}\n\n// <NSThread: 0x600000071d80>{number = 1, name = main}\n// aa =  0\n// aa =  1\n// aa =  2\n// <NSThread: 0x600000071d80>{number = 1, name = main}\n// bb =  0\n// bb =  1\n// bb =  2\n// <NSThread: 0x600000071d80>{number = 1, name = main}\n// cc =  0\n// cc =  1\n// cc =  2\n// end1"
    },
    {
      "type": "text",
      "data": "分析：串行，顺序执行。同步，不会开启新的线程。"
    },
    {
      "type": "text",
      "data": "2.串行异步"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "func serialWithAsync() {\n    serailQueue.async {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"aa = \",i)\n        }\n    }\n    serailQueue.async {\n        print(Thread.current)\n        for  i in 0 ..< 3 {\n            print(\"bb = \",i)\n        }\n    }\n    \n    serailQueue.async {\n        print(Thread.current)\n        for  i in 0 ..< 3 {\n            print(\"cc = \",i)\n        }\n    }\n    print(\"end2,\",Thread.current)\n}\n// <NSThread: 0x608000261c00>{number = 3, name = (null)}\n// aa =  0\n// aa =  1\n// end2, <NSThread: 0x608000074f40>{number = 1, name = main}\n// aa =  2\n// <NSThread: 0x608000261c00>{number = 3, name = (null)}\n// bb =  0\n// bb =  1\n// bb =  2\n// <NSThread: 0x608000261c00>{number = 3, name = (null)}\n// cc =  0\n// cc =  1\n// cc =  2"
    },
    {
      "type": "text",
      "data": "分析：串行队列中的任务按顺序执行，然异步任务会开启新的线程，所以三个任务是在新的线程中依次执行。且异步任务不会阻塞当前线程（main），所以结束标志语句在主线程中不受阻塞执行。"
    },
    {
      "type": "text",
      "data": "3.并行同步"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "func concurrentWithSync() {\n    concurrentQueue.sync {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"aa = \",i)\n        }\n    }\n    concurrentQueue.sync {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"bb = \",i)\n        }\n    }\n    \n    concurrentQueue.sync {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"cc = \",i)\n        }\n    }\n    print(\"end3\")\n}\n\n// <NSThread: 0x608000071e80>{number = 1, name = main}\n// aa =  0\n// aa =  1\n// aa =  2\n// <NSThread: 0x608000071e80>{number = 1, name = main}\n// bb =  0\n// bb =  1\n// bb =  2\n// <NSThread: 0x608000071e80>{number = 1, name = main}\n// cc =  0\n// cc =  1\n// cc =  2\n// end3"
    },
    {
      "type": "text",
      "data": "分析：并行，任务会并发执行。同步，不会开启新的线程，且会阻塞当前线程。此时虽然用的是并行队列，但同步任务并没有开启新的线程，所以并行执行也就无从说起，就会在当前线程按顺序完成任务。"
    },
    {
      "type": "text",
      "data": "4.并行异步"
    },
    {
      "type": "code",
      "language": "swift",
      "data": "func concurrentWithAsync() {\n    concurrentQueue.async {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"aa = \",i)\n        }\n    }\n    concurrentQueue.async {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"bb = \",i)\n        }\n    }\n    concurrentQueue.async {\n        print(Thread.current)\n        for i in 0 ..< 3 {\n            print(\"cc = \",i)\n        }\n    }\n    print(\"end4,\",Thread.current)\n}\n// aa, <NSThread: 0x600000263380>{number = 3, name = (null)}\n// end4, <NSThread: 0x600000077700>{number = 1, name = main}\n// bb, <NSThread: 0x600000263800>{number = 4, name = (null)}\n// aa =  0\n// cc, <NSThread: 0x6000002636c0>{number = 5, name = (null)}\n// bb =  0\n// aa =  1\n// cc =  0\n// aa =  2\n// cc =  1\n// bb =  1\n// cc =  2\n// bb =  2"
    },
    {
      "type": "text",
      "data": "分析：异步任务负责开启新的线程，并发队列负责在新的线程中多任务执行。"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}